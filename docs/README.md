## 프로그램 동작 흐름

- 도메인, 컨트롤러, 입, 출력 연결하기
- [x] 플레이어를 입력받는다.
- [x] 입력을 바탕으로 플레이어가 생성된다.
- [x] 플레이어 별로 플레이어 이동현황이 기본값으로 초기화된다.
- [x] 시도횟수를 입력받는다.
- [ ] 게임을 초기화 한다
- [ ] 플레이어들은 랜덤으로 배정받은 이동 여부에 따라 이동하거나 그대로 있는다.
- [ ] 한 이동당 한 번씩 이동결과를 출력한다.
- [ ] 시도횟수 만큼 게임을 반복해 진행한다.
- [ ] 게임 우승자를 판단한다.
- [ ] 게임 우승자를 출력한다.

## 기능 구현 목록

- 플레이어를 생성하는 기능 [Player]
    - [x] 이름 리스트를 받아서 Player 객체를 생성한다.
    - [x] PlayerName, isWinner를 필드로 갖는다.
- 플레이어 이동현황을 생성하는 기능 [PlayerMove]
    - [x] Player를 받아서 PlayerMove 객체를 생성한다.
    - [x]  PlayerMove 객체를 PlayerMoveList에 담는다.

- 랜덤 숫자를 생성하는 기능 [RandomNumberGenerator]
    - [x] 랜덤 숫자를 뽑는다.
        - 컨트롤러에서 객체를 생성해서 전진 여부 객체 생성 때 넣어주기
- 이동 여부를 배정하는 기능 [MoveFactory]
    - [x] 랜덤 숫자가 4이상인지 판단한다.
    - [x] 위의 뽑힌 랜덤 숫자에 의해 이동 여부를 반환한다.

- 게임을 진행한다. [RacingGame]
    - [x] 게임을 초기화 한다: 플레이어별 이동현황을 초기화하고 게임 상태를 진행으로 바꾼다.
    - 플레이어별 이동하는 기능
        - [x] 모든 플레이어에게 이동 여부를 배정한다.
        - [x] 배정받은 이동 여부에 따라 이동한다.
        - [x] 이동을 거리에 반영한다.
        - [x] 한 이동당 한 번씩 이동결과를 출력한다.

- 게임 승리 판단
    - [ ] 입력한 시도 횟수만큼 플레이어별 이동의 반복이 끝나면 게임은 멈춘다.
    - [x] 가장 이동한 거리가 가장 먼 사람이 우승자가 된다.
    - [ ] 우승자를 출력한다.
        - PlayerMoveList에 메시지를 보내서 isWinner가 true인 Player이 PlayerName을 반환하는 스트림이든 그런 걸로!

## 예외 처리

- (예외 상황 시 "[ERROR]"로 시작하는 에러 문구를 출력한다.)
- 플레이어 이름을 입력 받을 때 예외 상황
    - [x] 공백인 경우
    - [x] ,로 구분되지 않은 경우 (한 명인 경우도 안됨)
    - [x] 다섯자 초과인 경우
- 시도할 횟수를 입력 받을 때 예외 상황
    - [x] 공백인 경우
    - [x] 숫자가 아닌 경우
    - [x] 0안 경우

## 입출력 기능

### 입력 기능

- [x] 플레이어 이름을 입력받는 기능
- [ ] 시도할 횟수를 입력받는 기능

### 출력 기능

- [ ] 실행결과 문구를 출력
- [ ] 플레이어별 이동결과를 한 이동당 한번씩 출력
- [ ] 최종 우승자를 출력

-----
(추후 삭제)

# 필요한 객체들과 메소드를 생각해보자(추후 삭제)

-  [x] 컨트롤러에서는: 각 이동마다 PlayerMoveList를 갖고가서 출력하면 될듯?
    - [x] 아니면 responseDto로 만들어 갖고가서 출력하든지
    - 결과 출력에서 필요한 건 플레이어별 <playerName, distance>이 담긴 리스트? [현지, 1], [포비, 0]
    - PlayerName = PlayerMove.getPlayer.getPlayerName.getValue()
    - Distance = PlayerMove.getDistance.getValue()
- 얘는 최종에 반복 끝났을 때 필요함
    - isWinner = PlayerMove.getPlayer.getIsWinner();

## 보완할 점

- [x] 리스트 getter 부분에 unmodifiableList 추가
- [x] 생성자 파라미터의 final 키워드 추가
- [x] validate 위치 조정
- [x] racingGame의 move 메소드 의존성 주입 조정
- [ ] MoveFactory가 역할: 4이상 숫자 판단에 의해 boolean 값 반환밖에 없다.
    - [ ] 거기다 메소드 하나만 있어서 생성자에 말고 메소드에 바로 numbergenerator를 주입해도 되지 않을까하는 생각.
-[ ] distance에 대한 validate 체크
-[ ] 이외 입력받은 상황이 아니더라도, 생성자 부분에 validate가 필요한 부분 체크
- [ ] List<GameResultDto> gameResultDtoList 일급컬렉션화 하지 않아도 될까?

## 프로그래밍 요구 사항

- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
- 3항 연산자를 쓰지 않는다.
- 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.
- JUnit 5와 AssertJ를 이용하여 본인이 정리한 기능 목록이 정상 동작함을 테스트 코드로 확인한다.
    - 테스트 도구 사용법이 익숙하지 않다면 `test/java/study`를 참고하여 학습한 후 테스트를 구현한다.

## 자체 요구 사항

- 함수(또는 메서드)의 길이가 10라인을 넘어가지 않도록 구현한다.
- 배열 대신 컬렉션을 사용한다.
- 모든 원시 값과 문자열을 포장한다
- 일급 컬렉션을 쓴다.
- 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.

## TDD 원칙 ⭐️⭐️

- 원칙 1 - 실패하는 단위 테스트를 작성할 때까지 프로덕션 코드(production code)를 작성하지 않는다.
- 원칙 2 - 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 원칙 3 - 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

## TDD 사이클 ⭐️⭐️

1. 실패하는 테스트를 구현한다.
2. 테스트가 성공하도록 프로덕션 코드를 구현한다.
3. 프로덕션 코드와 테스트 코드를 리팩토링한다.

